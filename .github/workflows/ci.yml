name: Build WASM Artifacts (Clean)
on:
  workflow_dispatch:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

env:
  RUNTIME_REPO: https://github.com/Itexoft/runtime
  RUNTIME_REF: wasm-dylink-pinvoke-10.0
  CONFIG: Release

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: mcr.microsoft.com/dotnet-buildtools/prereqs:azurelinux-3.0-net10.0-webassembly-amd64
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: st-mm1
            threads: "false"
            mm: "1"
            copy_pack: "true"
          - name: st-mm2
            threads: "false"
            mm: "2"
            copy_pack: "false"
          - name: mt-mm1
            threads: "true"
            mm: "1"
            copy_pack: "true"
          - name: mt-mm2
            threads: "true"
            mm: "2"
            copy_pack: "false"
    env:
      ROOTFS_DIR: /crossrootfs/x64
      RUNTIME_ARTIFACTS_DIR: ${{ github.workspace }}/runtime/artifacts
      EM_CACHE_DIR: ${{ github.workspace }}/emscripten-cache
      CFLAGS: ""
      CXXFLAGS: ""
      CPPFLAGS: ""
      LDFLAGS: ""
      SDKROOT: ""
      MACOSX_DEPLOYMENT_TARGET: ""
      CMAKE_OSX_DEPLOYMENT_TARGET: ""
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read VERSION
        id: version
        run: |
          set -euo pipefail
          v="$(cat VERSION)"
          if [[ -z "$v" ]]; then
            echo "::error::VERSION is empty"
            exit 1
          fi
          echo "value=$v" >> "$GITHUB_OUTPUT"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      - name: Clone runtime
        run: |
          set -euo pipefail
          git clone --depth 1 --branch "${RUNTIME_REF}" "${RUNTIME_REPO}" runtime

      - name: Resolve build versions
        id: versions
        run: |
          set -euo pipefail
          emsdk_version="$(cat runtime/src/mono/browser/emscripten-version.txt)"
          if [[ -z "${emsdk_version}" ]]; then
            echo "::error::emscripten-version.txt is empty"
            exit 1
          fi
          icu_transport="$(python3 - <<'PY'
          import sys
          import xml.etree.ElementTree as ET
          path = "runtime/eng/Version.Details.props"
          try:
              root = ET.parse(path).getroot()
          except Exception as e:
              print(f"::error::Failed to parse {path}: {e}", file=sys.stderr)
              sys.exit(1)
          version = ""
          for prop in root.iter():
              if prop.tag.endswith("MicrosoftNETCoreRuntimeICUTransportPackageVersion"):
                  version = (prop.text or "").strip()
                  break
          if not version:
              print("::error::ICU transport package version not found in Version.Details.props", file=sys.stderr)
              sys.exit(1)
          print(version)
          PY
          )"
          echo "emsdk=$emsdk_version" >> "$GITHUB_OUTPUT"
          echo "icu=$icu_transport" >> "$GITHUB_OUTPUT"

      - name: Select local build roots
        id: roots
        run: |
          set -euo pipefail
          fs_type="$(stat -f -c %T "$GITHUB_WORKSPACE")"
          base="$GITHUB_WORKSPACE"
          case "$fs_type" in
            cifs|smb2|nfs|nfs4|fuse.sshfs)
              base="${RUNNER_TEMP:-/tmp}/runtime-wasm"
              ;;
          esac
          if [[ -z "$base" ]]; then
            echo "::error::LOCAL_BUILD_ROOT is empty"
            exit 1
          fi
          mkdir -p "$base"
          if ! command -v dotnet >/dev/null 2>&1; then
            echo "::error::dotnet not found in PATH"
            exit 1
          fi
          nuget_root="$(dotnet nuget locals global-packages -l | awk -F': ' '{print $2}' | tr -d '\r')"
          if [[ -z "$nuget_root" ]]; then
            echo "::error::Failed to resolve NuGet global-packages path"
            exit 1
          fi
          nuget_root="${nuget_root%/}"
          mkdir -p "$nuget_root"
          echo "NUGET_PACKAGES=$nuget_root" >> "$GITHUB_ENV"
          echo "LOCAL_BUILD_ROOT=$base" >> "$GITHUB_ENV"
          echo "EM_CACHE_DIR=$base/emscripten-cache/${{ matrix.name }}" >> "$GITHUB_ENV"
          echo "RUNTIME_ARTIFACTS_DIR=$GITHUB_WORKSPACE/runtime/artifacts" >> "$GITHUB_ENV"
          echo "FROZEN_CACHE=" >> "$GITHUB_ENV"
          echo "EM_FROZEN_CACHE=0" >> "$GITHUB_ENV"
          echo "EMCC_FROZEN_CACHE=0" >> "$GITHUB_ENV"
          echo "WORKSPACE_FS_TYPE=$fs_type" >> "$GITHUB_ENV"

      - name: Restore NuGet cache
        id: cache-nuget
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.NUGET_PACKAGES }}
          key: nuget-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ hashFiles('runtime/eng/Version.Details.xml') }}

      - name: Restore emsdk cache
        id: cache-emsdk
        uses: actions/cache/restore@v4
        with:
          path: runtime/src/mono/browser/emsdk
          key: emsdk-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ steps.versions.outputs.emsdk }}

      - name: Restore emscripten build cache
        id: cache-emcache
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.EM_CACHE_DIR }}
          key: emcache-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ steps.versions.outputs.emsdk }}-${{ matrix.name }}

      - name: Provision emsdk
        id: provision-emsdk
        run: |
          set -euo pipefail
          if [[ -z "${EM_CACHE_DIR:-}" ]]; then
            echo "::error::EM_CACHE_DIR is not set"
            exit 1
          fi
          emsdk_version="${{ steps.versions.outputs.emsdk }}"
          if [[ ! -d "$GITHUB_WORKSPACE/runtime/src/mono/browser/emsdk" ]]; then
            git clone https://github.com/emscripten-core/emsdk.git runtime/src/mono/browser/emsdk
          fi
          pushd runtime/src/mono/browser/emsdk
          if [[ ! -f "./emsdk" ]]; then
            echo "::error::emsdk script not found in runtime/src/mono/browser/emsdk"
            exit 1
          fi
          if [[ "${{ steps.cache-emsdk.outputs.cache-hit }}" != "true" ]]; then
            ./emsdk install "${emsdk_version}"
          fi
          ./emsdk activate "${emsdk_version}"
          popd
          if [[ ! -f "$GITHUB_WORKSPACE/runtime/src/mono/browser/emsdk/emsdk_env.sh" ]]; then
            echo "::error::emsdk_env.sh not found after emsdk install"
            exit 1
          fi
          emsdk_root="$GITHUB_WORKSPACE/runtime/src/mono/browser/emsdk"
          emscripten_up="$emsdk_root/upstream/emscripten"
          if [[ ! -d "$emscripten_up" ]]; then
            echo "::error::emscripten upstream not found: $emscripten_up"
            exit 1
          fi
          if [[ -e "$emsdk_root/emscripten" && ! -L "$emsdk_root/emscripten" ]]; then
            echo "::error::emscripten path exists and is not a symlink: $emsdk_root/emscripten"
            exit 1
          fi
          ln -sfn "$emscripten_up" "$emsdk_root/emscripten"
          stdio_ok=0
          if [[ -f "$emscripten_up/system/include/stdio.h" ]]; then
            stdio_ok=1
          elif [[ -f "$emscripten_up/system/lib/libc/musl/include/stdio.h" ]]; then
            stdio_ok=1
          elif [[ -f "$emscripten_up/cache/sysroot/include/stdio.h" ]]; then
            stdio_ok=1
          fi
          if [[ "$stdio_ok" -ne 1 ]]; then
            echo "::error::stdio.h not found under emscripten sysroot. Checked:"
            echo "  $emscripten_up/system/include/stdio.h"
            echo "  $emscripten_up/system/lib/libc/musl/include/stdio.h"
            echo "  $emscripten_up/cache/sysroot/include/stdio.h"
            exit 1
          fi
          mkdir -p "$emsdk_root/bin"
          tool_links=(
            "llvm-ar:$emsdk_root/upstream/bin/llvm-ar"
            "wasm-opt:$emsdk_root/upstream/bin/wasm-opt"
          )
          for entry in "${tool_links[@]}"; do
            name="${entry%%:*}"
            src="${entry#*:}"
            if [[ ! -x "$src" ]]; then
              echo "::error::Required emsdk tool not found or not executable: $src"
              exit 1
            fi
            ln -sfn "$src" "$emsdk_root/bin/$name"
            if [[ ! -x "$emsdk_root/bin/$name" ]]; then
              echo "::error::Tool symlink invalid: $emsdk_root/bin/$name"
              exit 1
            fi
          done
          echo "EMSDK_PATH=$emsdk_root" >> "$GITHUB_ENV"
          llvm_root="$emsdk_root/upstream/bin"
          if [[ ! -d "$llvm_root" ]]; then
            echo "::error::DOTNET_EMSCRIPTEN_LLVM_ROOT not found: $llvm_root"
            exit 1
          fi
          binaryen_root="$emsdk_root/upstream"
          if [[ ! -d "$binaryen_root" ]]; then
            echo "::error::DOTNET_EMSCRIPTEN_BINARYEN_ROOT not found: $binaryen_root"
            exit 1
          fi
          node_js="$emsdk_root/node/$(ls -1 "$emsdk_root/node" | head -n 1)/bin/node"
          if [[ ! -x "$node_js" ]]; then
            echo "::error::DOTNET_EMSCRIPTEN_NODE_JS not found: $node_js"
            exit 1
          fi
          echo "DOTNET_EMSCRIPTEN_LLVM_ROOT=$llvm_root" >> "$GITHUB_ENV"
          echo "DOTNET_EMSCRIPTEN_BINARYEN_ROOT=$binaryen_root" >> "$GITHUB_ENV"
          echo "DOTNET_EMSCRIPTEN_NODE_JS=$node_js" >> "$GITHUB_ENV"
          emcache="$EM_CACHE_DIR"
          mkdir -p "$emcache"
          cache_link="$emsdk_root/upstream/emscripten/cache"
          if [[ -e "$cache_link" && ! -L "$cache_link" ]]; then
            rm -rf "$cache_link"
          fi
          ln -sfn "$emcache" "$cache_link"

      - name: Export emsdk environment
        run: |
          set -euo pipefail
          if [[ -z "${EMSDK_PATH:-}" ]]; then
            echo "::error::EMSDK_PATH is not set"
            exit 1
          fi
          if [[ -z "${EM_CACHE_DIR:-}" ]]; then
            echo "::error::EM_CACHE_DIR is not set"
            exit 1
          fi
          emsdk_root="${EMSDK_PATH%/}"
          if [[ ! -f "$emsdk_root/emsdk_env.sh" ]]; then
            echo "::error::emsdk_env.sh not found: $emsdk_root/emsdk_env.sh"
            exit 1
          fi
          if [[ ! -x "$emsdk_root/upstream/emscripten/emcc" ]]; then
            echo "::error::emcc not found under EMSDK_PATH: $emsdk_root/upstream/emscripten/emcc"
            exit 1
          fi
          echo "EMSDK_PATH=$emsdk_root" >> "$GITHUB_ENV"
          echo "EM_CONFIG=$emsdk_root/.emscripten" >> "$GITHUB_ENV"
          echo "EM_CACHE=$EM_CACHE_DIR" >> "$GITHUB_ENV"
          echo "PATH=$emsdk_root/upstream/emscripten:$emsdk_root/upstream/bin:$PATH" >> "$GITHUB_ENV"

      - name: Save emsdk cache
        if: always() && steps.cache-emsdk.outputs.cache-hit != 'true' && steps.provision-emsdk.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: runtime/src/mono/browser/emsdk
          key: emsdk-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ steps.versions.outputs.emsdk }}

      - name: Restore runtime artifacts
        id: cache-runtime
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.RUNTIME_ARTIFACTS_DIR }}
          key: runtime-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ env.CONFIG }}-${{ env.RUNTIME_REF }}-${{ steps.versions.outputs.emsdk }}-${{ steps.versions.outputs.icu }}-threads-${{ matrix.threads }}-mm${{ matrix.mm }}

      - name: Ensure cache directories
        run: |
          set -euo pipefail
          if [[ -z "${NUGET_PACKAGES:-}" ]]; then
            echo "::error::NUGET_PACKAGES is not set"
            exit 1
          fi
          if [[ -z "${EM_CACHE_DIR:-}" ]]; then
            echo "::error::EM_CACHE_DIR is not set"
            exit 1
          fi
          if [[ -z "${RUNTIME_ARTIFACTS_DIR:-}" ]]; then
            echo "::error::RUNTIME_ARTIFACTS_DIR is not set"
            exit 1
          fi
          mkdir -p "$NUGET_PACKAGES"
          mkdir -p "$EM_CACHE_DIR"
          mkdir -p "$RUNTIME_ARTIFACTS_DIR"

      - name: Resolve ICU transport pack
        run: |
          set -euo pipefail
          icu_version="${{ steps.versions.outputs.icu }}"
          if [[ -z "$icu_version" ]]; then
            echo "::error::ICU transport version is empty"
            exit 1
          fi
          icu_root="$NUGET_PACKAGES/microsoft.netcore.runtime.icu.transport/$icu_version/runtimes/browser-wasm/native"
          echo "ICU_DIR=$icu_root" >> "$GITHUB_ENV"
          echo "ICU_LIB_DIR=$icu_root/lib" >> "$GITHUB_ENV"
      - name: Validate cached runtime artifacts
        if: steps.cache-runtime.outputs.cache-hit == 'true'
        run: |
          set -euo pipefail
          native_dir="$RUNTIME_ARTIFACTS_DIR/bin/native"
          wasm="$native_dir/net10.0-browser-$CONFIG-wasm/dotnet.native.wasm"
          if [[ ! -f "$wasm" ]]; then
            echo "::error::Cached runtime artifacts missing dotnet.native.wasm: $wasm"
            exit 1
          fi
          if [[ "${{ matrix.copy_pack }}" == "true" ]]; then
            pkg_dir="$RUNTIME_ARTIFACTS_DIR/packages/$CONFIG/Shipping"
            if [[ "${{ matrix.threads }}" == "true" ]]; then
              pkg_pattern="Microsoft.NETCore.App.Runtime.Mono.multithread.browser-wasm.*.nupkg"
            else
              pkg_pattern="Microsoft.NETCore.App.Runtime.Mono.browser-wasm.*.nupkg"
            fi
            shopt -s nullglob
            pkgs=()
            for candidate in "$pkg_dir"/$pkg_pattern; do
              if [[ "$candidate" == *.symbols.nupkg ]]; then
                continue
              fi
              pkgs+=("$candidate")
            done
            shopt -u nullglob
            if [[ "${#pkgs[@]}" -ne 1 ]]; then
              echo "::error::Expected exactly one runtime pack (non-symbols, $pkg_pattern) under $pkg_dir, found ${#pkgs[@]}"
              exit 1
            fi
          fi

      - name: Build
        id: build-runtime
        if: steps.cache-runtime.outputs.cache-hit != 'true'
        env:
          EXTRA_CFLAGS: "-fPIC"
          EXTRA_CXXFLAGS: "-fPIC"
        run: |
          set -euo pipefail
          cache="$EM_CACHE_DIR"
          mkdir -p "$cache"
          export EM_CACHE="$cache"

          extra_cflags="-I$ICU_DIR/include -fPIC -DWASM_SUPPORTS_DLOPEN=1"
          extra_ld="-s MAIN_MODULE=${{ matrix.mm }}"
          wasm_enable_simd="true"
          cmake_args="-DCMAKE_POSITION_INDEPENDENT_CODE=ON -DCLR_CMAKE_TARGET_OS=browser -DCLR_CMAKE_TARGET_ARCH=wasm -DCLR_CMAKE_TARGET_BROWSER=1"
          if [[ "${{ matrix.threads }}" == "true" ]]; then
            extra_cflags="${extra_cflags} -pthread"
            extra_ld="${extra_ld} -pthread -Wno-experimental"
          fi

          ./runtime/build.sh \
            -s mono.runtime+mono.wasmruntime+libs.native+packs \
            -os browser -arch wasm -c "$CONFIG" \
            /p:WasmEnableThreads=${{ matrix.threads }} \
            /p:BuildTests=false \
            /p:RunTests=false \
            "/p:ICULibDir=$ICU_LIB_DIR" \
            "/p:IcuDir=$ICU_DIR" \
            "/p:CMakeArgs=$cmake_args" \
            "/p:EmccExtraCFlags=$extra_cflags" \
            "/p:EmccExtraLDFlags=${extra_ld}" \
            "/p:WasmEnableSIMD=${wasm_enable_simd}" \
            "/p:WasmCachePath=$cache"

      - name: Collect diagnostics
        if: always()
        run: |
          set -euo pipefail
          out="$GITHUB_WORKSPACE/artifacts/diagnostics/${{ matrix.name }}"
          mkdir -p "$out"

          native_bin="$RUNTIME_ARTIFACTS_DIR/bin/native/net10.0-browser-Release-wasm"
          if [[ -d "$native_bin" ]]; then
            mkdir -p "$out/native-bin"
            if [[ -d "$native_bin/src" ]]; then
              cp -a "$native_bin/src" "$out/native-bin/"
            fi
            if [[ -f "$native_bin/CMakeCache.txt" ]]; then
              cp -f "$native_bin/CMakeCache.txt" "$out/native-bin/"
            fi
            for f in dotnet.native.wasm dotnet.native.js dotnet.native.js.map; do
              if [[ -f "$native_bin/$f" ]]; then
                cp -f "$native_bin/$f" "$out/native-bin/"
              fi
            done
          fi

          pack_base="$RUNTIME_ARTIFACTS_DIR/bin"
          if [[ "${{ matrix.threads }}" == "true" ]]; then
            pack_dir="$pack_base/microsoft.netcore.app.runtime.multithread.browser-wasm/$CONFIG/runtimes/browser-wasm/native"
          else
            pack_dir="$pack_base/microsoft.netcore.app.runtime.browser-wasm/$CONFIG/runtimes/browser-wasm/native"
          fi
          if [[ -d "$pack_dir" ]]; then
            mkdir -p "$out/runtime-pack"
            if [[ -f "$pack_dir/dotnet.native.wasm" ]]; then
              cp -f "$pack_dir/dotnet.native.wasm" "$out/runtime-pack/"
            fi
          fi

          obj_root="$RUNTIME_ARTIFACTS_DIR/obj/native/net10.0-browser-Release-wasm"
          if [[ -d "$obj_root" ]]; then
            mkdir -p "$out/obj-native"
            find "$obj_root" -type f \( -name "flags.make" -o -name "link.txt" -o -name "CMakeCache.txt" \) | while read -r f; do
              rel="${f#$obj_root/}"
              mkdir -p "$out/obj-native/$(dirname "$rel")"
              cp -f "$f" "$out/obj-native/$rel"
            done
          fi

          if [[ -f "$GITHUB_WORKSPACE/runtime/src/mono/browser/emsdk/.emscripten" ]]; then
            cp -f "$GITHUB_WORKSPACE/runtime/src/mono/browser/emsdk/.emscripten" "$out/"
          fi
          if [[ -f "$EM_CACHE_DIR/sanity.txt" ]]; then
            cp -f "$EM_CACHE_DIR/sanity.txt" "$out/"
          fi
          if [[ -d "$RUNTIME_ARTIFACTS_DIR/log" ]]; then
            cp -a "$RUNTIME_ARTIFACTS_DIR/log" "$out/"
          fi
          if [[ -d /tmp/emscripten_temp ]]; then
            tar -czf "$out/emscripten_temp.tgz" -C /tmp emscripten_temp
          fi

      - name: Save runtime artifacts cache
        if: always() && steps.cache-runtime.outputs.cache-hit != 'true' && steps.build-runtime.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: ${{ env.RUNTIME_ARTIFACTS_DIR }}
          key: runtime-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ env.CONFIG }}-${{ env.RUNTIME_REF }}-${{ steps.versions.outputs.emsdk }}-${{ steps.versions.outputs.icu }}-threads-${{ matrix.threads }}-mm${{ matrix.mm }}

      - name: Save emscripten build cache
        if: always() && steps.cache-emcache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ${{ env.EM_CACHE_DIR }}
          key: emcache-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ steps.versions.outputs.emsdk }}-${{ matrix.name }}

      - name: Save NuGet cache
        if: always() && steps.cache-nuget.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ${{ env.NUGET_PACKAGES }}
          key: nuget-${{ runner.os }}-v${{ steps.version.outputs.value }}-${{ hashFiles('runtime/eng/Version.Details.xml') }}

      - name: Assemble artifacts
        run: |
          set -euo pipefail
          out="$GITHUB_WORKSPACE/artifacts/${{ matrix.name }}"
          mkdir -p "$out/runtimes/browser-wasm/native"

          native_dir="$RUNTIME_ARTIFACTS_DIR/bin/native/net10.0-browser-$CONFIG-wasm"
          wasm="$native_dir/dotnet.native.wasm"

          suffix="st"
          if [[ "${{ matrix.threads }}" == "true" ]]; then
            suffix="mt"
          fi

          cp -f "$wasm" "$out/runtimes/browser-wasm/native/dotnet.native.${suffix}.dl.mm${{ matrix.mm }}.wasm"

          if [[ "${{ matrix.copy_pack }}" == "true" ]]; then
            pkg_dir="$RUNTIME_ARTIFACTS_DIR/packages/$CONFIG/Shipping"
            if [[ "${{ matrix.threads }}" == "true" ]]; then
              pkg_pattern="Microsoft.NETCore.App.Runtime.Mono.multithread.browser-wasm.*.nupkg"
            else
              pkg_pattern="Microsoft.NETCore.App.Runtime.Mono.browser-wasm.*.nupkg"
            fi
            shopt -s nullglob
            pkgs=()
            for candidate in "$pkg_dir"/$pkg_pattern; do
              if [[ "$candidate" == *.symbols.nupkg ]]; then
                continue
              fi
              pkgs+=("$candidate")
            done
            shopt -u nullglob
            if [[ "${#pkgs[@]}" -ne 1 ]]; then
              echo "::error::Expected exactly one runtime pack (non-symbols, $pkg_pattern) under $pkg_dir, found ${#pkgs[@]}"
              exit 1
            fi
            pkg="${pkgs[0]}"
            python3 - "$pkg" "$out" "${{ matrix.threads }}" <<'PY'
          import os
          import shutil
          import sys
          import zipfile

          pkg_path = sys.argv[1]
          out_dir = sys.argv[2]
          is_threads = sys.argv[3].lower() == "true"

          if not os.path.isfile(pkg_path):
              print(f"::error::Runtime pack not found: {pkg_path}", file=sys.stderr)
              sys.exit(1)

          with zipfile.ZipFile(pkg_path) as zf:
              entries = [n for n in zf.namelist() if n.startswith("runtimes/browser-wasm/")]
              if not entries:
                  print(f"::error::Runtime pack missing runtimes/browser-wasm in {pkg_path}", file=sys.stderr)
                  sys.exit(1)
              for name in entries:
                  dest = os.path.join(out_dir, name)
                  if name.endswith("/"):
                      os.makedirs(dest, exist_ok=True)
                      continue
                  os.makedirs(os.path.dirname(dest), exist_ok=True)
                  with zf.open(name) as src, open(dest, "wb") as dst:
                      shutil.copyfileobj(src, dst)

          if is_threads:
              src_dir = os.path.join(out_dir, "runtimes", "browser-wasm", "native")
              dst_dir = os.path.join(out_dir, "runtimes", "browser-wasm", "native.multithread")
              if not os.path.isdir(src_dir):
                  print(f"::error::Expected native runtime pack directory missing: {src_dir}", file=sys.stderr)
                  sys.exit(1)
              if os.path.exists(dst_dir):
                  print(f"::error::Target multithread directory already exists: {dst_dir}", file=sys.stderr)
                  sys.exit(1)
              os.rename(src_dir, dst_dir)
          PY
          fi

      - name: Collect NuGet packages
        if: matrix.copy_pack == 'true'
        run: |
          set -euo pipefail
          src="$RUNTIME_ARTIFACTS_DIR/packages/$CONFIG/Shipping"
          if [[ ! -d "$src" ]]; then
            echo "::error::NuGet packages directory not found: $src"
            exit 1
          fi
          out="$GITHUB_WORKSPACE/artifacts/nuget/${{ matrix.name }}"
          mkdir -p "$out"
          shopt -s nullglob
          pkgs=("$src"/*.nupkg "$src"/*.snupkg)
          if [[ "${#pkgs[@]}" -eq 0 ]]; then
            echo "::error::No NuGet packages found under $src"
            exit 1
          fi
          cp -f "${pkgs[@]}" "$out/"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: runtime-wasm-${{ matrix.name }}
          path: artifacts/${{ matrix.name }}
          if-no-files-found: error
          retention-days: 1

      - name: Upload NuGet packages
        if: matrix.copy_pack == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: runtime-wasm-nuget-${{ matrix.name }}
          path: artifacts/nuget/${{ matrix.name }}
          if-no-files-found: error
          retention-days: 1
